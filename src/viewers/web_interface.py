#!/usr/bin/env python3
"""
Web Interface for Image Analysis with CLIP and LLM

A modern Flask web application providing a user-friendly interface
for uploading images, viewing results, and managing configurations.
"""

import os
import json
import sys
import webbrowser
import threading
import time
from pathlib import Path
from datetime import datetime
from typing import Dict, Any, List, Optional

from flask import Flask, render_template, request, jsonify, send_file, redirect, url_for, flash, send_from_directory
from werkzeug.utils import secure_filename
import requests
from PIL import Image
import io
import base64

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from directory_processor import DirectoryProcessor
from src.database.db_manager import DatabaseManager
from src.analyzers.llm_manager import LLMManager
from dotenv import load_dotenv
import os

app = Flask(__name__)
app.secret_key = 'your-secret-key-here'  # Change this in production

# Load environment variables
load_dotenv()

# Configuration
# Get the project root directory (2 levels up from this file)
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
UPLOAD_FOLDER = os.path.join(PROJECT_ROOT, 'Images')
OUTPUT_FOLDER = os.path.join(PROJECT_ROOT, 'Output')
ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'bmp', 'tiff', 'webp'}
MAX_CONTENT_LENGTH = 50 * 1024 * 1024  # 50MB max file size
WEB_PORT = int(os.getenv('WEB_PORT', '5050'))

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = MAX_CONTENT_LENGTH

# Global variables
processing_status = {}
processing_threads = {}

# Initialize database manager and LLM manager
db_manager = DatabaseManager()
llm_manager = LLMManager()

def get_config():
    """Get current configuration from environment variables"""
    return {
        'API_BASE_URL': os.getenv('API_BASE_URL', 'http://localhost:7860'),
        'CLIP_MODEL_NAME': os.getenv('CLIP_MODEL_NAME', 'ViT-L-14/openai'),
        'ENABLE_CLIP_ANALYSIS': os.getenv('ENABLE_CLIP_ANALYSIS', 'True') == 'True',
        'ENABLE_LLM_ANALYSIS': os.getenv('ENABLE_LLM_ANALYSIS', 'True') == 'True',
        'IMAGE_DIRECTORY': os.path.join(PROJECT_ROOT, os.getenv('IMAGE_DIRECTORY', 'Images')),
        'OUTPUT_DIRECTORY': os.path.join(PROJECT_ROOT, os.getenv('OUTPUT_DIRECTORY', 'Output')),
        'CLIP_MODES': os.getenv('CLIP_MODES', 'best,fast,classic,negative,caption').split(','),
        'PROMPT_CHOICES': os.getenv('PROMPT_CHOICES', 'P1,P2').split(','),
        'LOGGING_LEVEL': os.getenv('LOGGING_LEVEL', 'INFO'),
        'RETRY_LIMIT': int(os.getenv('RETRY_LIMIT', '5')),
        'TIMEOUT': int(os.getenv('TIMEOUT', '60')),
        'WEB_PORT': int(os.getenv('WEB_PORT', '5050'))
    }

def update_config(config_data):
    """Update configuration in .env file"""
    try:
        env_file = os.path.join(PROJECT_ROOT, '.env')
        
        # Read existing .env file
        env_lines = []
        if os.path.exists(env_file):
            with open(env_file, 'r', encoding='utf-8') as f:
                env_lines = f.readlines()
        
        # Create a dictionary of existing settings
        env_dict = {}
        for line in env_lines:
            line = line.strip()
            if line and not line.startswith('#') and '=' in line:
                key, value = line.split('=', 1)
                env_dict[key] = value
        
        # Update with new values
        for key, value in config_data.items():
            if isinstance(value, list):
                env_dict[key] = ','.join(value)
            elif isinstance(value, bool):
                env_dict[key] = str(value).lower()
            else:
                env_dict[key] = str(value)
        
        # Write back to .env file
        with open(env_file, 'w', encoding='utf-8') as f:
            f.write("# Image Analysis Configuration\n")
            f.write("# Generated by web interface\n\n")
            
            for key, value in env_dict.items():
                f.write(f"{key}={value}\n")
        
        # Reload environment variables
        load_dotenv(env_file, override=True)
        
        # Update global configuration variables
        global WEB_PORT
        WEB_PORT = int(os.getenv('WEB_PORT', '5050'))
        
        print(f"Configuration updated successfully. New WEB_PORT: {WEB_PORT}")
        
        return True
    except Exception as e:
        print(f"Error updating config: {e}")
        return False

def create_thumbnail(image_path, size=(200, 200)):
    """Create a thumbnail for an image"""
    try:
        with Image.open(image_path) as img:
            # Convert to RGB if necessary
            if img.mode in ('RGBA', 'LA', 'P'):
                img = img.convert('RGB')
            
            # Create thumbnail
            img.thumbnail(size, Image.Resampling.LANCZOS)
            
            # Convert to base64 for inline display
            buffer = io.BytesIO()
            img.save(buffer, format='JPEG', quality=85)
            buffer.seek(0)
            
            return base64.b64encode(buffer.getvalue()).decode('utf-8')
    except Exception as e:
        print(f"Error creating thumbnail for {image_path}: {e}")
        return None

def get_thumbnail_data_url(image_path):
    """Get thumbnail as data URL"""
    thumbnail_data = create_thumbnail(image_path)
    if thumbnail_data:
        return f"data:image/jpeg;base64,{thumbnail_data}"
    return None

def allowed_file(filename):
    """Check if file extension is allowed"""
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def get_analysis_files():
    """Get list of analysis files with thumbnails"""
    analysis_files = []
    if os.path.exists(OUTPUT_FOLDER):
        for file in os.listdir(OUTPUT_FOLDER):
            if file.endswith('_analysis.json'):
                file_path = os.path.join(OUTPUT_FOLDER, file)
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        data = json.load(f)
                        
                        # Try to find the original image and generate thumbnail
                        original_image = data.get('file_info', {}).get('filename', 'Unknown')
                        original_path = data.get('file_info', {}).get('directory', 'Images')
                        full_image_path = os.path.join(original_path, original_image)
                        
                        thumbnail_url = None
                        if os.path.exists(full_image_path):
                            thumbnail_url = get_thumbnail_data_url(full_image_path)
                        
                        analysis_files.append({
                            'filename': file,
                            'original_image': original_image,
                            'status': data.get('processing_info', {}).get('status', 'unknown'),
                            'processing_time': data.get('processing_info', {}).get('processing_time', 0),
                            'date_processed': data.get('file_info', {}).get('date_processed', ''),
                            'file_size': data.get('file_info', {}).get('file_size', 0),
                            'has_clip': bool(data.get('analysis', {}).get('clip')),
                            'has_llm': bool(data.get('analysis', {}).get('llm')),
                            'has_metadata': bool(data.get('analysis', {}).get('metadata')),
                            'thumbnail': thumbnail_url
                        })
                except Exception as e:
                    print(f"Error loading {file}: {e}")
    return sorted(analysis_files, key=lambda x: x['date_processed'], reverse=True)

def get_image_files():
    """Get list of uploaded images with thumbnails"""
    image_files = []
    if os.path.exists(UPLOAD_FOLDER):
        for root, dirs, files in os.walk(UPLOAD_FOLDER):
            for file in files:
                if allowed_file(file):
                    file_path = os.path.join(root, file)
                    rel_path = os.path.relpath(file_path, UPLOAD_FOLDER)
                    
                    # Generate thumbnail
                    thumbnail_url = get_thumbnail_data_url(file_path)
                    
                    image_files.append({
                        'filename': file,
                        'path': rel_path,
                        'full_path': file_path,
                        'size': os.path.getsize(file_path),
                        'modified': datetime.fromtimestamp(os.path.getmtime(file_path)).isoformat(),
                        'thumbnail': thumbnail_url
                    })
    return sorted(image_files, key=lambda x: x['modified'], reverse=True)

def process_images_async():
    """Process images in background thread"""
    try:
        # Load configuration from environment variables
        config = {
            'API_BASE_URL': os.getenv('API_BASE_URL', 'http://localhost:7860'),
            'CLIP_MODEL_NAME': os.getenv('CLIP_MODEL_NAME', 'ViT-L-14/openai'),
            'ENABLE_CLIP_ANALYSIS': os.getenv('ENABLE_CLIP_ANALYSIS', 'True') == 'True',
            'ENABLE_LLM_ANALYSIS': os.getenv('ENABLE_LLM_ANALYSIS', 'True') == 'True',
            'ENABLE_PARALLEL_PROCESSING': os.getenv('ENABLE_PARALLEL_PROCESSING', 'False') == 'True',
            'ENABLE_METADATA_EXTRACTION': os.getenv('ENABLE_METADATA_EXTRACTION', 'True') == 'True',
            'IMAGE_DIRECTORY': os.path.join(PROJECT_ROOT, os.getenv('IMAGE_DIRECTORY', 'Images')),
            'OUTPUT_DIRECTORY': os.path.join(PROJECT_ROOT, os.getenv('OUTPUT_DIRECTORY', 'Output')),
            'CLIP_MODES': [mode.strip() for mode in os.getenv('CLIP_MODES', 'best,fast,classic,negative,caption').split(',')],
            'PROMPT_CHOICES': [p.strip() for p in os.getenv('PROMPT_CHOICES', 'P1,P2').split(',')],
            'DEBUG': os.getenv('DEBUG', 'False') == 'True',
            'FORCE_REPROCESS': os.getenv('FORCE_REPROCESS', 'False') == 'True',
            'GENERATE_SUMMARIES': os.getenv('GENERATE_SUMMARIES', 'True') == 'True'
        }
        
        processor = DirectoryProcessor(config)
        processor.process_directory()
        processing_status['status'] = 'completed'
        processing_status['message'] = 'Processing completed successfully!'
    except Exception as e:
        processing_status['status'] = 'error'
        processing_status['message'] = f'Error during processing: {str(e)}'

def open_browser():
    """Open browser after a short delay"""
    time.sleep(1.5)  # Wait for server to start
    try:
        webbrowser.open(f'http://localhost:{WEB_PORT}')
        print("🌐 Browser opened automatically!")
    except Exception as e:
        print(f"⚠️  Could not open browser automatically: {e}")
        print(f"📱 Please open your browser and navigate to: http://localhost:{WEB_PORT}")

@app.route('/')
def index():
    """Main dashboard"""
    analysis_files = get_analysis_files()
    image_files = get_image_files()
    
    # Get system stats
    total_images = len(image_files)
    total_analyses = len(analysis_files)
    completed_analyses = len([f for f in analysis_files if f['status'] == 'complete'])
    
    # Get recent activity
    recent_analyses = analysis_files[:5]
    
    return render_template('dashboard.html',
                         total_images=total_images,
                         total_analyses=total_analyses,
                         completed_analyses=completed_analyses,
                         recent_analyses=recent_analyses,
                         processing_status=processing_status)

@app.route('/upload', methods=['GET', 'POST'])
def upload():
    """Handle file uploads"""
    if request.method == 'POST':
        if 'file' not in request.files:
            flash('No file selected', 'error')
            return redirect(request.url)
        
        files = request.files.getlist('file')
        uploaded_count = 0
        
        for file in files:
            if file.filename == '':
                continue
            
            if file and allowed_file(file.filename):
                filename = secure_filename(file.filename)
                
                # Create subdirectory if specified
                subfolder = request.form.get('subfolder', '').strip()
                if subfolder:
                    upload_path = os.path.join(app.config['UPLOAD_FOLDER'], subfolder)
                    os.makedirs(upload_path, exist_ok=True)
                    filepath = os.path.join(upload_path, filename)
                else:
                    filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
                
                try:
                    file.save(filepath)
                    uploaded_count += 1
                except Exception as e:
                    flash(f'Error saving {filename}: {str(e)}', 'error')
        
        if uploaded_count > 0:
            flash(f'Successfully uploaded {uploaded_count} file(s)', 'success')
        
        return redirect(url_for('upload'))
    
    return render_template('upload.html')

@app.route('/images')
def images():
    """View uploaded images"""
    image_files = get_image_files()
    return render_template('images.html', images=image_files)

@app.route('/results')
def results():
    """View analysis results"""
    analysis_files = get_analysis_files()
    return render_template('results.html', analyses=analysis_files)

@app.route('/result/<path:filename>')
def view_result(filename):
    """View specific analysis result"""
    file_path = os.path.join(OUTPUT_FOLDER, filename)
    if not os.path.exists(file_path):
        flash('Analysis file not found', 'error')
        return redirect(url_for('results'))
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        return render_template('result_detail.html', data=data, filename=filename)
    except Exception as e:
        flash(f'Error loading analysis: {str(e)}', 'error')
        return redirect(url_for('results'))

@app.route('/process', methods=['GET', 'POST'])
def process():
    """Process images"""
    if request.method == 'POST':
        if processing_status.get('status') == 'processing':
            flash('Processing already in progress', 'warning')
            return redirect(url_for('process'))
        
        # Start processing in background
        processing_status['status'] = 'processing'
        processing_status['message'] = 'Starting image processing...'
        processing_status['start_time'] = datetime.now().isoformat()
        
        thread = threading.Thread(target=process_images_async)
        thread.daemon = True
        thread.start()
        processing_threads['main'] = thread
        
        flash('Processing started! Check status for updates.', 'success')
        return redirect(url_for('process'))
    
    return render_template('process.html', status=processing_status)

@app.route('/status')
def status():
    """Get processing status"""
    return jsonify(processing_status)

@app.route('/config', methods=['GET', 'POST'])
def config():
    """Configuration management"""
    if request.method == 'POST':
        try:
            # Update configuration
            config_data = request.get_json()
            if update_config(config_data):
                return jsonify({'status': 'success', 'message': 'Configuration saved successfully'})
            else:
                return jsonify({'status': 'error', 'message': 'Failed to save configuration'})
        except Exception as e:
            return jsonify({'status': 'error', 'message': str(e)})
    
    # Get current configuration
    current_config = get_config()
    return render_template('config.html', config=current_config)

@app.route('/download/<path:filename>')
def download_result(filename):
    """Download analysis result"""
    file_path = os.path.join(OUTPUT_FOLDER, filename)
    if os.path.exists(file_path):
        return send_file(file_path, as_attachment=True)
    else:
        flash('File not found', 'error')
        return redirect(url_for('results'))

@app.route('/api/analysis/<path:filename>')
def api_analysis(filename):
    """API endpoint to get analysis data"""
    file_path = os.path.join(OUTPUT_FOLDER, filename)
    if not os.path.exists(file_path):
        return jsonify({'error': 'File not found'}), 404
    
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        return jsonify(data)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/database')
def database_browser():
    """Database browser page"""
    try:
        # Get all results from database
        results = db_manager.get_all_results()
        
        # Process results for display
        processed_results = []
        for result in results:
            # Generate thumbnail if possible
            thumbnail_url = None
            image_path = os.path.join(result['directory'], result['filename'])
            if os.path.exists(image_path):
                thumbnail_url = get_thumbnail_data_url(image_path)
            
            processed_results.append({
                'id': result['id'],
                'filename': result['filename'],
                'directory': result['directory'],
                'md5': result['md5'],
                'model': result['model'],
                'modes': json.loads(result['modes']) if result['modes'] else [],
                'date_added': result['date_added'],
                'thumbnail': thumbnail_url,
                'has_prompts': bool(result['prompts']),
                'has_analysis': bool(result['analysis_results'])
            })
        
        return render_template('database.html', results=processed_results)
    except Exception as e:
        flash(f'Error loading database: {e}', 'error')
        return render_template('database.html', results=[])

@app.route('/api/database/result/<int:result_id>')
def api_database_result(result_id):
    """API endpoint to get database result by ID"""
    try:
        result = db_manager.get_result_by_id(result_id)
        if result:
            # Parse JSON fields
            result['modes'] = json.loads(result['modes']) if result['modes'] else []
            result['prompts'] = json.loads(result['prompts']) if result['prompts'] else {}
            result['analysis_results'] = json.loads(result['analysis_results']) if result['analysis_results'] else {}
            result['settings'] = json.loads(result['settings']) if result['settings'] else {}
            result['llm_results'] = json.loads(result['llm_results']) if result['llm_results'] else {}
            return jsonify(result)
        else:
            return jsonify({'error': 'Result not found'}), 404
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/llm-config')
def llm_config():
    """LLM configuration page"""
    try:
        # Get available models from all providers
        available_models = llm_manager.get_all_available_models()
        
        # Get configured models from database
        configured_models = db_manager.get_llm_models()
        
        # Test connections for all providers
        ollama_connected = llm_manager.test_ollama_connection()
        openai_connected = llm_manager.test_openai_connection()
        anthropic_connected = llm_manager.test_anthropic_connection()
        google_connected = llm_manager.test_google_connection()
        grok_connected = llm_manager.test_grok_connection()
        cohere_connected = llm_manager.test_cohere_connection()
        mistral_connected = llm_manager.test_mistral_connection()
        perplexity_connected = llm_manager.test_perplexity_connection()
        
        return render_template('llm_config.html', 
                             available_models=available_models,
                             configured_models=configured_models,
                             ollama_connected=ollama_connected,
                             openai_connected=openai_connected,
                             anthropic_connected=anthropic_connected,
                             google_connected=google_connected,
                             grok_connected=grok_connected,
                             cohere_connected=cohere_connected,
                             mistral_connected=mistral_connected,
                             perplexity_connected=perplexity_connected)
    except Exception as e:
        flash(f'Error loading LLM configuration: {e}', 'error')
        return render_template('llm_config.html', 
                             available_models=[],
                             configured_models=[],
                             ollama_connected=False,
                             openai_connected=False,
                             anthropic_connected=False,
                             google_connected=False,
                             grok_connected=False,
                             cohere_connected=False,
                             mistral_connected=False,
                             perplexity_connected=False)

@app.route('/api/llm/models')
def api_llm_models():
    """API endpoint to get available LLM models"""
    try:
        models = llm_manager.get_all_available_models()
        return jsonify(models)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/llm/configured')
def api_llm_configured():
    """API endpoint to get configured LLM models"""
    try:
        models = db_manager.get_llm_models()
        return jsonify(models)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/llm/add', methods=['POST'])
def api_llm_add():
    """API endpoint to add LLM model configuration"""
    try:
        data = request.get_json()
        
        # For all API-based models, don't store API key in database - use environment variables
        api_key = None
        model_type = data['type']
        
        # Check if API key is available for the model type
        if model_type in ['openai', 'anthropic', 'google', 'grok', 'cohere', 'mistral', 'perplexity']:
            env_key_map = {
                'openai': 'OPENAI_API_KEY',
                'anthropic': 'ANTHROPIC_API_KEY',
                'google': 'GOOGLE_API_KEY',
                'grok': 'GROK_API_KEY',
                'cohere': 'COHERE_API_KEY',
                'mistral': 'MISTRAL_API_KEY',
                'perplexity': 'PERPLEXITY_API_KEY'
            }
            
            env_key = env_key_map.get(model_type)
            if env_key:
                api_key = os.getenv(env_key)
                if not api_key:
                    return jsonify({'error': f'{model_type.upper()} API key not found in environment variables. Set {env_key} in your .env file.'}), 400
        
        db_manager.insert_llm_model(
            name=data['name'],
            type=data['type'],
            url=data.get('url'),
            api_key=api_key,  # Will be None for all API-based models
            model_name=data.get('model_name'),
            prompts=data.get('prompts')
        )
        return jsonify({'status': 'success', 'message': 'LLM model added successfully'})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/llm/delete/<int:model_id>', methods=['DELETE'])
def api_llm_delete(model_id):
    """API endpoint to delete LLM model configuration"""
    try:
        success = db_manager.delete_llm_model(model_id)
        if success:
            return jsonify({'status': 'success', 'message': 'LLM model deleted successfully'})
        else:
            return jsonify({'error': 'Failed to delete model'}), 500
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/llm/update-prompts/<int:model_id>', methods=['POST'])
def api_llm_update_prompts(model_id):
    """API endpoint to update LLM model prompts"""
    try:
        data = request.get_json()
        success = db_manager.update_llm_model_prompts(model_id, data.get('prompts'))
        if success:
            return jsonify({'status': 'success', 'message': 'Prompts updated successfully'})
        else:
            return jsonify({'error': 'Failed to update prompts'}), 500
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/prompts')
def prompts():
    """Prompt management page"""
    try:
        # Load prompts from the prompts.json file
        prompts_file = os.path.join(PROJECT_ROOT, 'src', 'config', 'prompts.json')
        prompts_data = {}
        
        if os.path.exists(prompts_file):
            with open(prompts_file, 'r', encoding='utf-8') as f:
                prompts_data = json.load(f)
        
        return render_template('prompts.html', prompts=prompts_data)
        
    except Exception as e:
        print(f"Error loading prompts page: {e}")
        flash(f'Error loading prompts: {str(e)}', 'error')
        return redirect(url_for('index'))

if __name__ == '__main__':
    # Create necessary directories
    os.makedirs(UPLOAD_FOLDER, exist_ok=True)
    os.makedirs(OUTPUT_FOLDER, exist_ok=True)
    
    print("🌐 Starting Web Interface...")
    print(f"📁 Project root: {PROJECT_ROOT}")
    print(f"📁 Upload folder: {UPLOAD_FOLDER}")
    print(f"📁 Output folder: {OUTPUT_FOLDER}")
    print(f"🚀 Server starting at http://localhost:{WEB_PORT}")
    
    # Start browser opening in background thread
    browser_thread = threading.Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    app.run(debug=True, host='0.0.0.0', port=WEB_PORT) 