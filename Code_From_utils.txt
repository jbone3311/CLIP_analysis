
###### FILENAME: api_analysis.py ######

import os
import json
import requests
import logging

def send_clip_request(data, api_url, timeout, config):
    """Send a request to the CLIP API."""
    try:
        response = requests.post(f"{api_url}/interrogator/prompt", json=data, timeout=timeout)
        response.raise_for_status()
        log_api_communication(api_url, "/interrogator/prompt", data, response, config)
        return response.json()
    except requests.exceptions.RequestException as e:
        logging.error(f"CLIP API request failed: {e}")
        logging.error(f"Request payload (without image): {json.dumps({k: v for k, v in data.items() if k != 'image'}, indent=2)}")
        return None

def send_llm_request(data, api_key):
    """Send a request to the LLM API."""
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}"
    }

    try:
        response = requests.post("https://api.openai.com/v1/chat/completions", headers=headers, json=data)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        logging.error(f"LLM API request failed: {e}")
        # Log request payload excluding 'image' data
        reduced_data = {k: v for k, v in data.items() if k != 'messages'}
        logging.error(f"Request payload: {json.dumps(reduced_data, indent=2)}")
        return None

def is_llm_json_valid(json_path):
    """Check if the LLM JSON file is valid (exists and is not null)."""
    if not os.path.exists(json_path):
        return False
    try:
        with open(json_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
            if data:
                return True
    except (IOError, json.JSONDecodeError):
        return False
    return False

def test_api(api_base_url: str, timeout: int) -> bool:
    """Test the API by hitting the health endpoint."""
    try:
        response = requests.get(f"{api_base_url}/info", timeout=timeout)
        response.raise_for_status()
        return True
    except requests.exceptions.RequestException as e:
        logging.error(f"API test failed: {e}")
        return False

def create_data(image_data, prompt_text, temperature, max_tokens, role, system_content, model, top_p=1.0, frequency_penalty=0.0, presence_penalty=0.0):
    """Create the payload data for the API request."""
    return {
        "model": model,
        "messages": [
            {"role": "system", "content": system_content},
            {"role": role, "content": prompt_text},
            {"role": role, "content": {"type": "image_url", "image_url": {"url": image_data}}}
        ],
        "temperature": temperature,
        "max_tokens": max_tokens,
        "top_p": top_p,
        "frequency_penalty": frequency_penalty,
        "presence_penalty": presence_penalty
    }

def log_api_communication(api_url, endpoint, request_data, response, config):
    """Log API communication if enabled in the configuration."""
    if config.log_api_communication:
        log_data = {
            "url": f"{api_url}{endpoint}",
            "request": {k: v for k, v in request_data.items() if k != 'image'},  # Exclude image data from log
            "response_status_code": response.status_code,
            "response_text": response.text
        }
        log_file_path = os.path.join(config.output_directory, 'api_communication_log.json')
        try:
            with open(log_file_path, 'a', encoding='utf-8') as log_file:
                json.dump(log_data, log_file, indent=2)
                log_file.write('\n')
        except IOError as e:
            logging.error(f"Failed to write API communication log: {e}")


###### FILENAME: api_utils.py ######

import json
import requests
import logging

# Function to test the API
def test_api(api_base_url: str, timeout: int) -> bool:
    """
    Test the API by hitting the health endpoint.
    
    :param api_base_url: Base URL of the API.
    :param timeout: Timeout duration for the request.
    :return: True if the API is responsive, False otherwise.
    """
    try:
        response = requests.get(f"{api_base_url}/info", timeout=timeout)
        response.raise_for_status()
        return True
    except requests.exceptions.RequestException:
        return False

# Function to send a request to the LLM API
def send_llm_request(data: dict, api_key: str) -> dict:
    """
    Send a request to the LLM API.

    :param data: The payload to send to the API.
    :param api_key: The API key for authentication.
    :return: The response from the API.
    """
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}"
    }
    try:
        response = requests.post("https://api.openai.com/v1/chat/completions", headers=headers, json=data)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.HTTPError as http_err:
        logging.error(f'HTTP error occurred: {http_err}')
    except requests.exceptions.ConnectionError as conn_err:
        logging.error(f'Error connecting to the API: {conn_err}')
    except requests.exceptions.Timeout as timeout_err:
        logging.error(f'Timeout error: {timeout_err}')
    except requests.exceptions.RequestException as req_err:
        logging.error(f'An error occurred with the API request: {req_err}')
    return None

# Function to check if the LLM JSON data is valid
def is_llm_json_valid(json_data: dict) -> bool:
    """
    Check if the LLM JSON data is valid.

    :param json_data: The JSON data to check.
    :return: True if the data is valid, False otherwise.
    """
    required_keys = ['model', 'messages', 'temperature', 'max_tokens']
    return all(key in json_data for key in required_keys)

# Function to create the data payload for the LLM request
def create_data(image_url: str, prompt_text: str, temperature: float, max_tokens: int, role: str, system_content: str, model: str, top_p: float = 1.0, frequency_penalty: float = 0.0, presence_penalty: float = 0.0) -> dict:
    """
    Create the data payload for the LLM request.

    :param image_url: The URL of the image.
    :param prompt_text: The prompt text to send to the LLM.
    :param temperature: The temperature setting for the LLM.
    :param max_tokens: The maximum number of tokens for the LLM response.
    :param role: The role of the message sender.
    :param system_content: The system content for the LLM.
    :param model: The model to use for the LLM.
    :param top_p: The top-p setting for the LLM.
    :param frequency_penalty: The frequency penalty setting for the LLM.
    :param presence_penalty: The presence penalty setting for the LLM.
    :return: The data payload as a dictionary.
    """
    return {
        "model": model,
        "messages": [
            {
                "role": role,
                "content": [
                    {"type": "text", "text": prompt_text},
                    {
                        "type": "image_url",
                        "image_url": {
                            "url": image_url
                        }
                    }
                ]
            }
        ],
        "temperature": temperature,
        "max_tokens": max_tokens,
        "top_p": top_p,
        "frequency_penalty": frequency_penalty,
        "presence_penalty": presence_penalty
    }

# Function to analyze an image in detail by sending it to the API with multiple caption types
def analyze_image_detailed(image_base64: str, model: str, caption_types: list, api_base_url: str, timeout: int, config) -> dict:
    """
    Analyze an image in detail by sending it to the API with multiple caption types.

    :param image_base64: Base64 encoded image.
    :param model: Model name to use for analysis.
    :param caption_types: List of caption types to generate.
    :param api_base_url: Base URL of the API.
    :param timeout: Timeout duration for the request.
    :param config: Configuration object.
    :return: Detailed results including prompts and analysis data.
    """
    detailed_results = {"prompts": {}}
    for caption_type in caption_types:
        try:
            payload = {"image": image_base64, "clip_model_name": model, "mode": caption_type}
            
            if config.log_api_communication:
                logging.debug(f"API URL: {api_base_url}/interrogator/prompt")
                logging.debug(f"Payload (excluding image): {json.dumps({k: v for k, v in payload.items() if k != 'image'})}")

            response = requests.post(f"{api_base_url}/interrogator/prompt", json=payload, timeout=timeout)
            response.raise_for_status()

            if config.log_api_communication:
                logging.debug(f"Response: {response.status_code} - {response.text}")

            detailed_results["prompts"][caption_type] = response.json().get('prompt')
        except requests.exceptions.HTTPError as http_err:
            logging.error(f'HTTP error occurred: {http_err}')
            detailed_results["prompts"][caption_type] = None
        except requests.exceptions.ConnectionError as conn_err:
            logging.error(f'Error connecting to the API: {conn_err}')
            detailed_results["prompts"][caption_type] = None
        except requests.exceptions.Timeout as timeout_err:
            logging.error(f'Timeout error: {timeout_err}')
            detailed_results["prompts"][caption_type] = None
        except requests.exceptions.RequestException as req_err:
            logging.error(f'An error occurred with the API request: {req_err}')
            detailed_results["prompts"][caption_type] = None

    try:
        payload = {"image": image_base64, "clip_model_name": model}
        
        if config.log_api_communication:
            logging.debug(f"API URL: {api_base_url}/interrogator/analyze")
            logging.debug(f"Payload (excluding image): {json.dumps({k: v for k, v in payload.items() if k != 'image'})}")
    
        response = requests.post(f"{api_base_url}/interrogator/analyze", json=payload, timeout=timeout)
        response.raise_for_status()
    
        if config.log_api_communication:
            logging.debug(f"Response: {response.status_code} - {response.text}")
    
        analysis_data = response.json()
        detailed_results["analysis"] = analysis_data
    except requests.exceptions.HTTPError as http_err:
        logging.error(f'HTTP error occurred: {http_err}')
        detailed_results["analysis"] = None
    except requests.exceptions.ConnectionError as conn_err:
        logging.error(f'Error connecting to the API: {conn_err}')
        detailed_results["analysis"] = None
    except requests.exceptions.Timeout as timeout_err:
        logging.error(f'Timeout error: {timeout_err}')
        detailed_results["analysis"] = None
    except requests.exceptions.RequestException as req_err:
        logging.error(f'An error occurred with the API request: {req_err}')
        detailed_results["analysis"] = None

    return detailed_results


###### FILENAME: image_utils.py ######

import base64
import hashlib
import logging
from PIL import Image, UnidentifiedImageError
from io import BytesIO

def generate_unique_code(image_path):
    """Generate a unique SHA-256 hash for an image file.

    Args:
        image_path (str): Path to the image file.

    Returns:
        str: SHA-256 hash of the image, or None if an error occurs.
    """
    try:
        with Image.open(image_path) as img:
            with BytesIO() as img_byte_array:
                img.save(img_byte_array, format=img.format)
                img_byte_data = img_byte_array.getvalue()
                return hashlib.sha256(img_byte_data).hexdigest()
    except FileNotFoundError as e:
        logging.error("Image file not found: %s - %s", image_path, e)
    except UnidentifiedImageError as e:
        logging.error("Cannot identify image file: %s - %s", image_path, e)
    except Exception as e:
        logging.error("Error generating unique code for image %s: %s", image_path, e)
    return None

def resize_image(image, max_size=(512, 512)):
    """Resize the image to fit within max_size while maintaining aspect ratio.

    Args:
        image (PIL.Image): Image to resize.
        max_size (tuple): Maximum width and height.

    Returns:
        PIL.Image: Resized image.
    """
    image.thumbnail(max_size, Image.ANTIALIAS)
    return image

def encode_image_to_base64(image_path):
    """Encode an image file to a base64 string.

    Args:
        image_path (str): Path to the image file.

    Returns:
        str: Base64 encoded string of the image, or None if an error occurs.
    """
    try:
        with Image.open(image_path) as img:
            img = resize_image(img)  # Resize the image before encoding
            imgio = BytesIO()
            img.save(imgio, 'JPEG')
            imgio.seek(0)
            data = base64.b64encode(imgio.read())
            return data.decode('utf8')
    except FileNotFoundError as e:
        logging.error("Image file not found: %s - %s", image_path, e)
    except UnidentifiedImageError as e:
        logging.error("Cannot identify image file: %s - %s", image_path, e)
    except Exception as e:
        logging.error("Error encoding image to base64: %s", e)
    return None

def process_image_for_analysis(image_path):
    """Process an image for analysis by resizing and converting to JPEG if needed.

    Args:
        image_path (str): Path to the image file.

    Returns:
        str: Base64 encoded string of the processed image, or None if an error occurs.
    """
    try:
        with Image.open(image_path) as img:
            # Check if the image is already 512x512 or smaller and in JPEG format
            if img.size[0] <= 512 and img.size[1] <= 512 and img.format == 'JPEG':
                return encode_image_to_base64(image_path)
            else:
                # Resize and convert to JPEG
                img = resize_image(img)
                imgio = BytesIO()
                img.save(imgio, 'JPEG')
                imgio.seek(0)
                data = base64.b64encode(imgio.read())
                return data.decode('utf8')
    except FileNotFoundError as e:
        logging.error("Image file not found: %s - %s", image_path, e)
    except UnidentifiedImageError as e:
        logging.error("Cannot identify image file: %s - %s", image_path, e)
    except Exception as e:
        logging.error("Error processing image for analysis: %s", e)
    return None


###### FILENAME: json_utils.py ######

import os
import json
import logging
import time

def save_json(file_path, data):
    """
    Save data to a JSON file.

    Args:
        file_path: Path to the JSON file.
        data: Data to be saved.
    """
    try:
        with open(file_path, 'w', encoding='utf-8') as json_file:
            json.dump(data, json_file, ensure_ascii=False, indent=4)
        logging.info(f"JSON output created: {file_path}")
    except IOError as e:
        logging.error(f"Failed to create or write to file: {e}, Path attempted: {file_path}")

def get_existing_json_files(directory):
    """
    Get the list of existing JSON files in the given directory.

    Args:
        directory: Directory to search for JSON files.

    Returns:
        list: List of JSON filenames found.
    """
    json_files = []
    for root, _, files in os.walk(directory):
        json_files.extend([file for file in files if file.lower().endswith('_clip_analysis.json')])
    return json_files

def process_existing_json_files(config):
    """
    Process existing JSON files and generate text files containing prompt lists.

    Args:
        config: Configuration object.
    """
    clip_analysis_dir = os.path.join(config.output_directory, 'CLIP_analysis')
    os.makedirs(clip_analysis_dir, exist_ok=True)

    for subdir in os.listdir(config.image_directory):
        subdir_path = os.path.join(config.image_directory, subdir)
        if os.path.isdir(subdir_path):
            logging.debug(f"Looking into JSON directory: {subdir_path}")
            batch_json_dir = os.path.join(subdir_path, 'json')
            if not os.path.exists(batch_json_dir):
                logging.info(f"JSON directory does not exist: {batch_json_dir}")
                continue
            else:
                logging.info(f"Found JSON directory: {batch_json_dir}")

            for root, _, files in os.walk(batch_json_dir):
                logging.debug(f"Processing existing JSON files in directory: {root}")
                prompt_lists = {caption_type: [] for caption_type in config.caption_types}

                json_files = [file for file in files if file.lower().endswith('_clip_analysis.json')]
                if not json_files:
                    logging.info(f"No JSON files found in {root}")
                    continue

                for json_file in json_files:
                    json_full_path = os.path.join(root, json_file)
                    logging.debug(f"Reading JSON file: {json_full_path}")
                    try:
                        with open(json_full_path, 'r', encoding='utf-8') as f:
                            data = json.load(f)
                    except Exception as e:
                        logging.error(f"Failed to read JSON file {json_full_path}: {e}")
                        continue

                    for caption_type in config.caption_types:
                        if caption_type in data.get('prompts', {}):
                            prompt = data['prompts'][caption_type]
                            if prompt:
                                prompt_lists[caption_type].append(prompt)

                if config.create_prompt_list:
                    for caption_type, prompts in prompt_lists.items():
                        if prompts:
                            list_filename = f"{subdir}_{caption_type}_Prompts.txt"
                            list_path = os.path.join(clip_analysis_dir, list_filename)
                            logging.debug(f"Writing prompt list file: {list_path}")
                            try:
                                with open(list_path, config.list_file_mode, encoding='utf-8') as f:
                                    f.write('\n'.join(prompts))
                                logging.info(f"{time.strftime('%d/%m/%y %H:%M')} {list_filename}")
                            except Exception as e:
                                logging.error(f"Failed to write to file {list_path}: {e}")


###### FILENAME: logging_setup.py ######

import os
import logging

def setup_logging(config):
    """
    Setup logging configurations based on the configuration values.
    """
    log_to_file = config.log_to_file
    log_to_console = config.log_to_console
    log_file = config.log_file
    log_mode = config.log_mode
    output_directory = config.output_directory

    logging.getLogger().handlers.clear()

    log_format = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%d/%m/%y %H:%M')
    console_log_format = logging.Formatter('%(message)s')

    if log_to_file:
        log_file_path = os.path.join(output_directory, log_file)
        os.makedirs(output_directory, exist_ok=True)
        file_handler = logging.FileHandler(log_file_path, mode=log_mode, encoding='utf-8')
        file_handler.setFormatter(log_format)
        file_handler.setLevel(logging.DEBUG)
        logging.getLogger().addHandler(file_handler)

    if log_to_console:
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(console_log_format)
        console_handler.setLevel(logging.INFO)
        console_handler.setStream(open(1, 'w', encoding='utf-8', closefd=False))
        logging.getLogger().addHandler(console_handler)

    logging.getLogger().setLevel(logging.DEBUG)
    logging.getLogger('PIL').setLevel(logging.WARNING)



###### FILENAME: __init__.py ######

# utils/__init__.py
# This file ensures the `utils` subdirectory is treated as a package.


