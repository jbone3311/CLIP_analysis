## Directory Structure ##
./
    .env
    .gitignore
    analysis_main.py
    analyzer.py
    api_utils.py
    Before Refactor (OLD CODE).zip
    clip_analyzer.py
    CodeSheetConfig.ini
    Code_From_CWD.txt
    config.py
    Dir_Structure.txt
    image_utils.py
    Info.txt
    json_utils.py
    llm_analyzer.py
    LLM_CodeSheetV2.exe
    logging_setup.py
    TEST.py
    utils.py
    .git/
        COMMIT_EDITMSG
        config
        description
        FETCH_HEAD
        HEAD
        index
        ORIG_HEAD
        hooks/
            applypatch-msg.sample
            commit-msg.sample
            fsmonitor-watchman.sample
            post-update.sample
            pre-applypatch.sample
            pre-commit.sample
            pre-merge-commit.sample
            pre-push.sample
            pre-rebase.sample
            pre-receive.sample
            prepare-commit-msg.sample
            push-to-checkout.sample
            update.sample
        info/
            exclude
        logs/
            HEAD
            refs/
                heads/
                    main
                remotes/
                    origin/
                        main
        objects/
            00/
                d1f703ed65a512edaa66502a788801006f11d4
            01/
                363af75eef02ef1dfe65d39d7dc2927ec113b8
            04/
                c9e599e36b7f2ced28a31af4a36b88b9b1bff3
            05/
                858c7d0808f3d64570a77f8aca34823fe02421
            06/
                f0cfda7d8b1490d0602d0a251ba23ddd083e1a
            09/
                b55fca364bc89b6bda729320fe45e2e4a61f5e
            0a/
                7ac1a4e73c95918a4f207740529fad15bd6f79
            10/
                5dbceb4f9ea2e2cc11e2d0bd06cea2954b4f0e
            11/
                0ca06e42e4d77e52122b762f20c3b5c74847c8
            12/
                2d2a82ce9f57349263c2f1d912401b34afbb6f
            14/
                143012ca8153a65b874692a7593376d731ea99
                a0be5e43b999d23e0afc2b63a48509e5c03698
            17/
                1c35e99f5fabe2d12bf39568f56ef5e4bda197
            19/
                7f42d48dbe921a275f108f85233d16d5c66462
            1a/
                62411753d4eb1b19712bffd299a390c08121e4
            1b/
                46ca506b3812182d9e11e97555226ee8c3d608
                57956dbad23f674846e8b4fb07e6c65dafe321
                78c71243e361a5122527e13e7731f566781ce5
            20/
                8fdd5f53a04175ce4eeca994ff0a0373654475
            21/
                8087db7dc42d4b59095e693f098aa95afca11e
            23/
                12dfd9e73360e76dafa950adf8b411338fe109
            28/
                1d703ca8a5e6418ab67f938ae8057f971bf80d
            2a/
                cc6e4ed4d6f4d7f288927a6ccdd401279e7772
            2c/
                edc9273b09e8e813e7d478cfcbd1a8ac965a9c
                fd812683bb4fdf6001036cd2e00a094d8ecbce
            2e/
                a313fbd02d944d30b438b31f80bc4e1dc2db80
                b037b49e9a5830d449588525ba62f54a8d4372
                fe36e980b21d7aa98fb5a27d9d53893a7da829
            2f/
                0f77ac982253b588dc76aafc91f519fdb729d3
                85059977ee9d5233b15cb94ea0c4a29816e365
            32/
                62d8691b43dbf277aed243f0cd778340dc29ca
            33/
                29cc6a54226af9ec4b353625d22853bcd36ba2
                5a859abbddcf85ddcc458b7f3b7db482838cf4
            3a/
                0f13e0500d93ae06abecdf94050e2d6af326b4
            3b/
                104d6b2a1f8eb2df76cae16e0e0d2091e63a12
            3c/
                da5ea0c5fc4b06b99414f0faeb6df98c530c96
            3f/
                2c76c4b88c79d6df4de57c222b671bc4acdd34
            41/
                384258cd3593f174e6af4c3323b3b0b6b501b7
                f1921a29240ed1564acec36df3cf39716e2476
            42/
                ddc18de1559f43c55209177e90e32348e9eac4
            43/
                1a30a922f1ef2c666f42e8fe7b9ca3504cb1f3
            44/
                27e5315e9b6138c2aabe66b2b7ee161b977c8b
                ae09b40013728d0071e07ed89b660dd14cbd0c
            46/
                accc6aed2be2b2c358fbfd3d9846a45e42e15b
            48/
                5442c29d4a13e963f0e1e2e9482bb5af519d3e
            4a/
                9a2d86738ed2a39105a3788850ef385aa640a7
                ed745baa7e38a63bb7302b5f640855cde8e679
            4b/
                14f6ceaf1225250abff5fdb7aea8d89e2ecaf9
            4c/
                05e6aa8483cd23c67c2397bf8a59eb4809ec95
                cfe63fe69ceca170be867ad14d31f736231797
            4e/
                74bcde14be10fed65ed87d21cc920519e19edc
                86f0211bbc4e2e5e6a9f6afb2c49fef903d894
                9effc7b30be4839161c70452622a11e443e96c
            51/
                d1d770fff8a73b002e5e3e215755aaf1bdbe1a
            52/
                694e94af0c0105262746eeb9181a660eeed06c
            53/
                77a3dd45c706f304d0d2499685ceae792c492d
            54/
                a83c5cc6112abb8e0ee6a85dc3f4d5c4228415
            55/
                502ad96551fea27292a1205fb34b97760a0c0d
            56/
                5030af84d2c8ab2949905806a6c99dd0776446
                f880e2a49b1647a160ee5e8819d914567abf60
            57/
                904a1fc9edeb43977fd1bb07bdd607f3441c93
            5a/
                78e63225f64f6875a303048540a3ef790e2d34
                ac8448b1fa20361f792198006ca2a0212a2f25
            5b/
                ab203d7fd24bb58540da9e8c610f7f54003200
            5f/
                adfa6d90e9bc9741cdd40755773d957a245095
            61/
                5bb3be1143988082690293e03c5b36e6747a58
            65/
                716bf88866d42cb1f5cef4c514887d19445afb
            67/
                b5577a351307a2e9b975c5734b135437e9db54
            69/
                c8d00bcf98864c3c91e4a3296ec0d6b386b0a9
                dc7b841248c3c73ca0fc890d9de37e1a44cdaa
            6b/
                769b87c40351060454e1b84a9daa5cdb524aad
                c36623b07e74449ac34659003c661d6a4dfb1a
            6d/
                18c9c2c08f8cbd79e8c352d0e2973a22427679
                45e7981c7d25399e5a276ae2a3d72c369ff9a7
            70/
                3d65a3bb61c4f017136bd9a9bac25bba05dba9
            71/
                62c335a318aed858d7779f04a01790f964921b
            72/
                70cc991c88a7347b64e3ec42a84a9734ad6259
                e4833b738a5572dbedad149277f07720e5a50e
            73/
                15aab94c64699b12a627f26dacb02f8c9c0d78
            75/
                51de04ed3eba2c8544e06b4b0d38fce0b9674e
            78/
                a222d0efa3298d595a599855100f15a2d6db43
            7b/
                50f2ae5e7f7211dc1f6949e6312f11512989aa
            7d/
                1c6434bb60de5226147d616ef01015e76000f0
            7e/
                55972ad34b1dd3bdbc8cf86d0843a477693bb4
                8c35f7895bbf25ce2ee4261ec452edbb208f03
            80/
                ce59828d7a25f49d11904781121bd47517b323
            81/
                34429f5efbc0ed84cbf64affa2cf35a34bdd25
            83/
                3543101dbaae482f79d04f022be1faeca1a3a3
            84/
                078c4469f2b1670f2e6a6a6ad2fd292484a161
            85/
                33268ec2390c8eeae927d4dabc425f81aa35c6
                f7b1098fbd59ed03a3881be001556d46fc845e
            87/
                60912767c664e8f900950f3c2d331a6476adbb
            8a/
                428ed09dbdd3da9e3e27f1f1cd091d31c405cd
            8b/
                a4bd4f7da2fbf6cb2a4e0d0f41f9125888e15a
            8e/
                51200d0afc7bb0a5ef144342941835a007ea23
            90/
                c5250571b418089881d0b370cb55a907b017f4
                e84a4dffe271af2d9148f99d0418dedc9af356
            91/
                935678916e0f61138543914e188a355a904266
            92/
                cf921f497e678e14658c4c7de4a81e28df60e6
            96/
                3119b18d3e674dc39dd50cd947766f8804175a
                95b74168640e69e1d274691349cd936f627984
            97/
                149e0b7f0469fbc9779b9cce95d01cf7a5936d
                9688056d0242ac45154065bdab70483d1d7099
            98/
                1b97272287ef06f7cbd808f559a9b39add68ad
            9a/
                c7c4daf231acb6017e5665dc60f32218cd2851
            9b/
                6cec43bcc4c94c51d1e955baf6a3dd44378bd0
            9c/
                db5cf19b5cf482f2d42c36b834006ef1c2958d
            9d/
                746a318e38dac971deb5009d8512325d1da827
            a0/
                3fa8673995438b9224ef5b6304da6d775a8adf
            a1/
                8178521adb7ecce93bbb082ea4f395d65b3a9d
            a3/
                027d680fb49487f69498a9c66d1bb9efdb0237
            a4/
                5b147aff201a09ee8e9d2d13b10bfcb8b2e8ff
            a7/
                1511e577aba3df3db583474232e2c5889bc739
                ace3e8665fe8f03447cb7cf5d724e9f86e374a
                db5c341cae337b13d55a0c0bb12d0e8efb1d46
            aa/
                658af92755e48a2fbdb812f4190715a2a77cf0
            ac/
                ec98edd4b0631ae63d7edb6f8734aaa39f563e
            ad/
                67d44dc5247004866e1d24e8f9b08e4416dbbc
                b7e5d4e5c042d57d92efc7af0bb20a4fc96400
                f90431bdf5e7d1e30777331c7cc97886889172
            ae/
                ab11aae483224397c149b7475b70d138065749
                ba0cf0a3eec7eea9ab7772ffe930d2ca397510
            af/
                34c0b5a9696a6c974eb00da64c9180a776be28
            b0/
                370f431754ff6a2edc5740791cd1e57fce1f96
            b1/
                106780ffbbf9555e07f3c2897fd5cf666b5184
                23e9eafb63e1e877662a6901e188748f1b4741
            b2/
                2d20743c0b25f7566f05852a7e9d637f645f7f
                5719bebf12cbe95293eb2eb6bca6f931a2fdec
                f60574e41d7d2978e9cdd927c23cc1ec8e5ba7
            b3/
                84f7fb77024b52f25c6ad199cf21c13c88e8a5
            b4/
                fc0b239360654a3a8648c9ccde04146861d5e0
            b5/
                8088ca3135ea3e2f7d4b02ee2265545c46b989
            b8/
                4c0c4337f120d22493446a26fd784f6b850d7d
                ad5967c8bdec65edc17f0b58ec8ac27f3262d3
            bb/
                542e24557ff8f99a31532d7d3e8489886093d0
            bc/
                fa9923e522703fea3e83c4483b1f345ae6dfab
            bd/
                f97c1eae29597d19e85db9e9e8a77a02fc45fe
            be/
                683c86f5317a1ee8214a8e95e23f852a242cf6
            c1/
                3ed53a153e9d2023db56af9fe8d12b9a717d89
                e0435a7842299b1234dfed5764ab273502b3b9
            c2/
                4eaeaff48e0ebdc13ffbca84dd7e132fedc7d5
                f9d504ac572b3d45b96b031e585bf14991da22
            c5/
                aab2196d73c5947a78a3747f760c55c4b818cb
            c6/
                a4695b849273244563318679a53bf779a2d02b
                b5f3dceaec9e009841aedca32685ee0b8e5f85
            c8/
                7cd4553b546b5196a662fcc0f3bf80d8cf907f
            c9/
                48b53fa029eb204d6f2970e3bddadf680ae8f8
            ca/
                26d08467178daef794f2ba1f2b5bad6e003db0
                4bbc13a7698526ed65bac1e5f89a00d5c0ed27
            cc/
                5a3e94aab3fe6c863db25169cdce6911ea166e
            cf/
                9f31dfd6de924a0bfe4616b9eeba53b8abd9ae
            d3/
                fba730d874eff953bdc1e742c2d8fc1b46a3e1
            d4/
                8ecf06614c250592352cf7a48f84ae2aa11b91
            d6/
                ef30e2314f2251d3c873ae82703ec1823e4e78
                f9ac1143e5a83fb9098f1c9d9962b4a4ff58a3
            dc/
                cdfff6a508dced40da8f154dc86d45b09d1ba9
                e8c2758e73889730abc761bb36ce1e349ebcb6
            de/
                06f27cf0925950ed2c0d31e3f75d17aaf29a6e
            df/
                ff068b1634dd3ab77befb0ab3bc80f1ac44386
            e4/
                a07393b7876f6bfd0a4566551f1be18f61f5cd
            e6/
                ac88c99108d0a3c782c62f4ca1782ccdf90e44
                f53c5789c536767397f11de18cb4135fe9712c
            e7/
                149f6a5e0642d4a0feb1d2b19e240e898bac91
            e9/
                c598f088daf091434a18a9d40b8d850a17a979
            ea/
                26810b53e5cc2f06b7ba0ed4e00090f669748a
            eb/
                2519db0f8902504097140f8158ce293c2e9110
            ec/
                cf94bbb9e32d164fda7f37cf066bc5c7c68dc3
                e5edab650abc7f8644c76cb807251ba0ec8512
            ed/
                622d6f6c5b5c3cbd39a7fbbf9c92d0e9eaad27
                7a416949d6e9e2210f9b6b0ce80567b88ebdf1
            ee/
                87a46978f18fdb25851e35f51c6b0a81e82827
            ef/
                6bce238e104eb332cf32412035c0d075aba6a0
            f0/
                806596afc054a21f4d41303b3be69969c54dbf
            f2/
                654353c1fc0e2f13dbf7511e38c2cbe425a2cc
            f3/
                03345aab6ab56c019888d5fe3589440af8bbaf
            f7/
                0003326dacac408227f6f763c2464a122d61c3
                b494fbdf6fdfd3a858c31774d5a950ac88128a
                c9ff214039b361b36b444292bd03950750fcb9
                f58c77405e25b3061c8ed0bcccff1c96eb4847
            f8/
                eaa8a3848d53bf6b2337c92aafc684912cb49d
            fb/
                60d4b3b1ffe94e3056b9ae7d827709aeb7bd5d
            ff/
                2668437496ced2701b56bf8cd2992c76575fef
                362cbcbd5616d12a6f2dcd4349713b66590e0a
            info/
            pack/
        refs/
            heads/
                main
            remotes/
                origin/
                    main
            tags/
    Images/
        2/
            FarSide (26).jpg
            RANDOS (20).png
        Group/
            Group (1).png
            Group (2).png
            Group (3).png
            Group (4).png
            Group (5).png
            Group (6).png
            Group (7).png
    Output/
        api_clip.log
        api_communication.log
        api_llm.log
        Log.log
        1/
            1_best_Prompts.txt
            1_caption_Prompts.txt
            1_classic_Prompts.txt
            1_fast_Prompts.txt
            1_negative_Prompts.txt
        2/
            2_best_Prompts.txt
            2_caption_Prompts.txt
            2_classic_Prompts.txt
            2_fast_Prompts.txt
            2_negative_Prompts.txt
        CLIP_analysis/
            1_best_Prompts.txt
            1_caption_Prompts.txt
            1_classic_Prompts.txt
            1_fast_Prompts.txt
            1_negative_Prompts.txt
            2_best_Prompts.txt
            2_caption_Prompts.txt
            2_classic_Prompts.txt
            2_fast_Prompts.txt
            2_negative_Prompts.txt
            test_best_Prompts.txt
            test_caption_Prompts.txt
            test_classic_Prompts.txt
            test_fast_Prompts.txt
            test_negative_Prompts.txt
        test/
            test_best_Prompts.txt
            test_caption_Prompts.txt
            test_classic_Prompts.txt
            test_fast_Prompts.txt
            test_negative_Prompts.txt

## Main Directory ##

###### FILENAME: analysis_main.py ######

import logging
from dotenv import load_dotenv
from config import Config
from logging_setup import setup_logging
from clip_analyzer import CLIPAnalyzer
from llm_analyzer import LLMAnalyzer
from json_utils import process_existing_json_files


load_dotenv()

def main():
    try:
        config = Config()
        setup_logging(config)

        logging.info("### Processing New Batch ###")

        if config.enable_clip_analysis:
            logging.info("Running CLIP Analyzer...")
            clip_analyzer = CLIPAnalyzer(config)
            clip_analyzer.process_images()

        if config.enable_llm_analysis:
            logging.info("Running LLM Analyzer...")
            llm_analyzer = LLMAnalyzer(config)
            llm_analyzer.process_images()

        if config.enable_json_processing:
            logging.info("Processing existing JSON files...")
            process_existing_json_files(config)

    except Exception as e:
        logging.exception(f"An unexpected error occurred: {e}")

if __name__ == "__main__":
    main()


###### FILENAME: analyzer.py ######

import os
import json
import logging
import time
from abc import ABC, abstractmethod
from typing import Dict, List, Any
from image_utils import generate_unique_code  # Make sure this import is correct
import json_utils

class Analyzer(ABC):
    def __init__(self, config):
        self.config = config
        self.directory = config.image_directory
        self.output_directory = config.output_directory
        self.logger = logging.getLogger(self.__class__.__name__)
        self.enabled_modes = self._get_enabled_modes()

    @abstractmethod
    def _get_enabled_modes(self) -> List[str]:
        pass

    @abstractmethod
    def analyze_image(self, image_path: str, modes: List[str]) -> Dict[str, Any]:
        pass

    def process_images(self):
        existing_files = json_utils.get_existing_json_files(self.output_directory)
        for image_path in self.get_image_files():
            json_filename = f"{os.path.splitext(os.path.basename(image_path))[0]}_{self.__class__.__name__}.json"
            json_path = os.path.join(self.output_directory, json_filename)

            if json_filename in existing_files:
                existing_data = self._load_existing_json(json_path, image_path)
                if existing_data:
                    new_modes = self._get_new_modes(existing_data)
                    if not new_modes:
                        self.logger.info(f"Skipping {image_path}, all modes already processed.")
                        continue
                    else:
                        self.logger.info(f"Processing new modes for {image_path}: {new_modes}")
                        result = self.analyze_image(image_path, new_modes)
                        self._update_existing_json(json_path, result)
                else:
                    result = self.analyze_image(image_path, self.enabled_modes)
                    self.save_result(json_path, result)
            else:
                result = self.analyze_image(image_path, self.enabled_modes)
                self.save_result(json_path, result)

    def _load_existing_json(self, json_path: str, image_path: str) -> Dict[str, Any]:
        try:
            with open(json_path, 'r') as f:
                data = json.load(f)

            current_hash = generate_unique_code(image_path)
            if current_hash != data['file_info']['unique_hash']:
                self.logger.warning(f"Hash mismatch for {image_path}. Reprocessing image.")
                return {}

            return data
        except Exception as e:
            self.logger.error(f"Error loading JSON for {json_path}: {str(e)}")
            return {}

    def _get_new_modes(self, existing_data: Dict[str, Any]) -> List[str]:
        existing_modes = set(existing_data['analysis'].keys())
        return [mode for mode in self.enabled_modes if mode not in existing_modes]

    def _update_existing_json(self, json_path: str, new_data: Dict[str, Any]):
        try:
            with open(json_path, 'r+') as f:
                existing_data = json.load(f)
                existing_data['analysis'].update(new_data['analysis'])
                existing_data['file_info']['date_processed'] = time.time()
                f.seek(0)
                json.dump(existing_data, f, indent=4)
                f.truncate()
            self.logger.info(f"Updated JSON file: {json_path}")
        except Exception as e:
            self.logger.error(f"Error updating JSON file {json_path}: {str(e)}")

    def save_result(self, json_path: str, result: Dict[str, Any]):
        json_filename = f"{os.path.splitext(os.path.basename(json_path))[0]}_{self.__class__.__name__}.json"
        json_path = os.path.join(self.output_directory, json_filename)
        os.makedirs(os.path.dirname(json_path), exist_ok=True)
        with open(json_path, 'w') as f:
            json.dump(result, f, indent=4)
        self.logger.info(f"Saved results to {json_path}")

    def get_image_files(self):
        for root, _, files in os.walk(self.directory):
            for file in files:
                if file.lower().endswith(tuple(self.config.image_file_extensions)):
                    yield os.path.join(root, file)

    def _get_file_info(self, image_path: str) -> Dict[str, Any]:
        try:
            unique_hash = generate_unique_code(image_path)
        except NameError:
            self.logger.warning("generate_unique_code function not found. Using filename as hash.")
            unique_hash = os.path.basename(image_path)
        
        return {
            'filename': os.path.basename(image_path),
            'unique_hash': unique_hash,
            'date_created': os.path.getctime(image_path),
            'date_processed': time.time(),
            'file_size': os.path.getsize(image_path)
        }



###### FILENAME: api_utils.py ######

import logging
import time
import json
import os
from functools import wraps
from typing import Callable, Dict, Any, Optional
import requests

def log_api_conversation(logger: logging.Logger, data: Dict[str, Any]):
    logger.debug("API Conversation:")
    logger.debug(json.dumps(data, indent=2))

def retry_with_backoff(max_retries: int = 3, backoff_factor: int = 2):
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            retries = 0
            while retries < max_retries:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    wait = backoff_factor ** retries
                    logging.warning(f"Request failed: {e}. Retrying in {wait} seconds...")
                    time.sleep(wait)
                    retries += 1
            return func(*args, **kwargs)
        return wrapper
    return decorator

@retry_with_backoff()
def send_llm_request(data: Dict[str, Any], api_key: str, api_url: str, timeout: float = 30.0) -> Dict[str, Any]:
    llm_logger = logging.getLogger('LLM_API')
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}"
    }
    try:
        response = requests.post(api_url, json=data, headers=headers, timeout=timeout)
        response.raise_for_status()
        response_data = response.json()
        log_api_conversation(llm_logger, {"request": data, "response": response_data})
        return response_data
    except requests.RequestException as e:
        llm_logger.error(f"Error in LLM API request: {str(e)}")
        llm_logger.error(f"Response content: {e.response.text if e.response else 'No response content'}")
        raise

def safe_api_call(func: Callable[..., Dict[str, Any]]) -> Callable[..., Optional[Dict[str, Any]]]:
    @wraps(func)
    def wrapper(*args: Any, **kwargs: Any) -> Optional[Dict[str, Any]]:
        try:
            return func(*args, **kwargs)
        except requests.RequestException as e:
            logging.error(f"API call failed: {str(e)}")
            return None
    return wrapper


###### FILENAME: clip_analyzer.py ######

import os
import logging
import requests
from typing import Dict, Any, List
from analyzer import Analyzer
from api_utils import retry_with_backoff, log_api_conversation
from image_utils import encode_image_to_base64
import json_utils  # Add this import

class CLIPAnalyzer(Analyzer):
    def __init__(self, config):
        super().__init__(config)
        self.logger = logging.getLogger('CLIP_API')

    def _get_enabled_modes(self):
        return [mode for mode, enabled in {
            'caption': self.config.enable_caption,
            'best': self.config.enable_best,
            'fast': self.config.enable_fast,
            'classic': self.config.enable_classic,
            'negative': self.config.enable_negative
        }.items() if enabled]

    @retry_with_backoff(max_retries=3, backoff_factor=2)
    def send_clip_request(self, image_base64: str, mode: str) -> Dict[str, Any]:
        headers = {"Content-Type": "application/json"}
        payload = {
            "image": image_base64,
            "model": self.config.clip_model_name,
            "mode": mode
        }
        
        try:
            response = requests.post(
                f"{self.config.api_base_url}/interrogator/prompt", 
                json=payload, 
                headers=headers, 
                timeout=self.config.timeout
            )
            response.raise_for_status()
            response_data = response.json()
            
            log_payload = {**payload, "image": "[BASE64_IMAGE_CONTENT]"}
            log_api_conversation(self.logger, {"request": log_payload, "response": response_data})
            
            return {
                'result': response_data,
                'model': self.config.clip_model_name,
                'mode': mode
            }
        except requests.RequestException as e:
            self.logger.error(f"Error in CLIP API request (mode: {mode}): {str(e)}")
            self.logger.error(f"Response content: {e.response.text if e.response else 'No response content'}")
            raise

    def analyze_image(self, image_path: str, modes: List[str]) -> Dict[str, Any]:
        try:
            image_base64 = encode_image_to_base64(image_path)
            if image_base64 is None:
                raise ValueError(f"Failed to encode image: {image_path}")
            
            results = {}
            for mode in modes:
                self.logger.info(f"Analyzing image {os.path.basename(image_path)} with mode: {mode}")
                results[mode] = self.send_clip_request(image_base64, mode)
            
            return {
                'file_info': self._get_file_info(image_path),
                'analysis': results
            }
        except Exception as e:
            self.logger.error(f"Error analyzing image {image_path}: {str(e)}")
            return {
                'file_info': self._get_file_info(image_path),
                'analysis': {'error': str(e)}
            }

    def _get_file_info(self, image_path: str) -> Dict[str, Any]:
        return {
            'filename': os.path.basename(image_path),
            'unique_hash': generate_unique_code(image_path),
            'date_created': os.path.getctime(image_path),
            'date_processed': time.time(),
            'file_size': os.path.getsize(image_path)
        }

    def process_images(self):
        existing_files = json_utils.get_existing_json_files(self.config.output_directory)
        for image_path in self.get_image_files():
            if json_utils.should_process_file(image_path, existing_files, self.__class__.__name__, self.config):
                result = self.analyze_image(image_path, self.enabled_modes)
                self.save_result(image_path, result)

    def get_image_files(self):
        for root, _, files in os.walk(self.config.image_directory):
            for file in files:
                if file.lower().endswith(tuple(self.config.image_file_extensions)):
                    yield os.path.join(root, file)



###### FILENAME: config.py ######

import os
from dotenv import load_dotenv
from typing import Dict, Any

load_dotenv()

class Config:
    """
    Configuration class for managing application settings.
    Loads settings from environment variables with default values.
    """

    def __init__(self):
        # API Keys
        self.serper_api_key = os.getenv('SERPER_API_KEY')
        self.openai_api_key = os.getenv('OPENAI_API_KEY')
        self.google_api_key = os.getenv('GOOGLE_API_KEY')
        self.google_cse_id = os.getenv('GOOGLE_CSE_ID')
        self.agentops_api_key = os.getenv('AGENTOPS_API_KEY')

        # API Configuration
        self.api_base_url = os.getenv('API_BASE_URL', 'http://127.0.0.1:7860')
        self.timeout = int(os.getenv('TIMEOUT', '30'))

        # Directory Settings
        self.image_directory = os.getenv('IMAGE_DIRECTORY', 'Images')
        self.output_directory = os.getenv('OUTPUT_DIRECTORY', 'Output')

        # Logging Configuration
        self.logging_level = os.getenv('LOGGING_LEVEL', 'DEBUG')
        self.logging_format = os.getenv('LOGGING_FORMAT', '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        self.log_to_console = os.getenv('LOG_TO_CONSOLE', 'True').lower() == 'true'
        self.log_to_file = os.getenv('LOG_TO_FILE', 'True').lower() == 'true'
        self.log_file = os.getenv('LOG_FILE', 'Log.log')
        self.log_mode = 'w'  # Always overwrite log file
        self.log_api_communication = os.getenv('LOG_API_COMMUNICATION', 'True').lower() == 'true'

        # Model Settings
        self.clip_model_name = os.getenv('CLIP_MODEL_NAME', 'ViT-L-14/openai')
        self.caption_types = os.getenv('CAPTION_TYPES', 'caption,best,fast,classic,negative').split(',')

        # LLM Settings
        self.llm_api_base_url = os.getenv('LLM_API_BASE_URL', 'https://api.openai.com/v1/chat/completions')
        self.llm_model = os.getenv('LLM_MODEL', 'gpt-4')
        self.llm_system_content = os.getenv('LLM_SYSTEM_CONTENT', 'Your default system content here')

        # File Handling Settings
        self.create_individual_files = os.getenv('CREATE_INDIVIDUAL_FILES', 'True').lower() == 'true'
        self.create_prompt_list = os.getenv('CREATE_PROMPT_LIST', 'True').lower() == 'true'
        self.create_master_files = os.getenv('CREATE_MASTER_FILES', 'True').lower() == 'true'
        self.list_file_mode = os.getenv('LIST_FILE_MODE', 'w')
        self.master_analysis_filename = os.getenv('MASTER_ANALYSIS_FILENAME', 'master_analysis.json')
        self.process_json_without_images = os.getenv('PROCESS_JSON_WITHOUT_IMAGES', 'False').lower() == 'true'

        # Image File Extensions
        self.image_file_extensions = os.getenv('IMAGE_FILE_EXTENSIONS', '.png,.jpg,.jpeg').split(',')

        # LLM Configurations
        self.llms = self._load_llm_configs()

        # Analysis Control
        self.enable_clip_analysis = os.getenv('ENABLE_CLIP_ANALYSIS', 'True').lower() == 'true'
        self.enable_llm_analysis = os.getenv('ENABLE_LLM_ANALYSIS', 'True').lower() == 'true'
        self.enable_json_processing = os.getenv('ENABLE_JSON_PROCESSING', 'True').lower() == 'true'

        # Retry Configuration
        self.retry_limit = int(os.getenv('RETRY_LIMIT', '5'))
        self.sleep_interval = int(os.getenv('SLEEP_INTERVAL', '5'))

        # LLM Parameters
        self.temperature = float(os.getenv('TEMPERATURE', '0.7'))
        self.max_tokens = int(os.getenv('MAX_TOKENS', '300'))
        self.top_p = float(os.getenv('TOP_P', '1.0'))
        self.frequency_penalty = float(os.getenv('FREQUENCY_PENALTY', '0.0'))
        self.presence_penalty = float(os.getenv('PRESENCE_PENALTY', '0.0'))

        # Selected Prompts
        self.selected_prompts = [p for p in os.getenv('SELECTED_PROMPTS', '').split(',') if p]

        # New Analysis Modes
        self.enable_caption = os.getenv('ENABLE_CAPTION', 'True').lower() == 'true'
        self.enable_best = os.getenv('ENABLE_BEST', 'True').lower() == 'true'
        self.enable_fast = os.getenv('ENABLE_FAST', 'True').lower() == 'true'
        self.enable_classic = os.getenv('ENABLE_CLASSIC', 'True').lower() == 'true'
        self.enable_negative = os.getenv('ENABLE_NEGATIVE', 'True').lower() == 'true'

    def _load_llm_configs(self) -> Dict[str, Dict[str, Any]]:
        llms = {}
        for i in range(1, 5):  # Assuming a maximum of 4 LLM configurations
            enabled = os.getenv(f'LLM_{i}_ENABLED', 'False').lower() == 'true'
            if enabled:
                llms[f'LLM_{i}'] = {
                    'api_url': os.getenv(f'LLM_{i}_API_URL'),
                    'api_key': os.getenv(f'LLM_{i}_API_KEY'),
                }
        return llms

    def get_openai_api_key(self) -> str:
        return self.openai_api_key  # Make sure this attribute is set in the __init__ method

    def get_prompt_options(self, prompt_id: str) -> Dict[str, Any]:
        return {
            'PROMPT_TEXT': os.getenv(f'{prompt_id.upper()}_PROMPT_TEXT', 'Default prompt text'),
            'TEMPERATURE': float(os.getenv(f'{prompt_id.upper()}_TEMPERATURE', str(self.temperature))),
            'MAX_TOKENS': int(os.getenv(f'{prompt_id.upper()}_MAX_TOKENS', str(self.max_tokens)))
        }

    def _get_enabled_modes(self):
        return [mode for mode, enabled in {
            'caption': self.enable_caption,
            'best': self.enable_best,
            'fast': self.enable_fast,
            'classic': self.enable_classic,
            'negative': self.enable_negative
        }.items() if enabled]

    def __str__(self) -> str:
        return f"""
        Configuration:
        - API Base URL: {self.api_base_url}
        - Timeout: {self.timeout}
        - Image Directory: {self.image_directory}
        - Output Directory: {self.output_directory}
        - CLIP Model: {self.clip_model_name}
        - CLIP Mode: {self.clip_mode}
        - LLM Model: {self.llm_model}
        - Enable CLIP Analysis: {self.enable_clip_analysis}
        - Enable LLM Analysis: {self.enable_llm_analysis}
        - Enable JSON Processing: {self.enable_json_processing}
        """


###### FILENAME: image_utils.py ######

import base64
import hashlib
import logging
from typing import Optional, Tuple
from PIL import Image, UnidentifiedImageError
from io import BytesIO
import os

def generate_unique_code(image_path: str) -> str:
    with open(image_path, "rb") as f:
        file_hash = hashlib.md5()
        chunk = f.read(8192)
        while chunk:
            file_hash.update(chunk)
            chunk = f.read(8192)
    return file_hash.hexdigest()

def resize_image(image: Image.Image, max_size: Tuple[int, int] = (512, 512)) -> Image.Image:
    """Resize the image to fit within max_size while maintaining aspect ratio.

    Args:
        image (PIL.Image): Image to resize.
        max_size (tuple): Maximum width and height.

    Returns:
        PIL.Image: Resized image.
    """
    image.thumbnail(max_size, Image.LANCZOS)
    return image

def encode_image_to_base64(image_path: str) -> str:
    try:
        with Image.open(image_path) as img:
            # Convert image to RGB if it's not
            if img.mode != 'RGB':
                img = img.convert('RGB')
            with io.BytesIO() as buffer:
                img.save(buffer, format="JPEG")
                return base64.b64encode(buffer.getvalue()).decode()
    except UnidentifiedImageError:
        logging.error(f"Cannot identify image file: {image_path}")
    except IOError:
        logging.error(f"Cannot open image file: {image_path}")
    except Exception as e:
        logging.error(f"Error processing image {image_path}: {str(e)}")
    return None

def process_image_for_analysis(image_path: str) -> Optional[str]:
    """Process an image for analysis by resizing and converting to JPEG if needed.

    Args:
        image_path (str): Path to the image file.

    Returns:
        Optional[str]: Base64 encoded string of the processed image, or None if an error occurs.
    """
    try:
        with Image.open(image_path) as img:
            # Check if the image is already 512x512 or smaller and in JPEG format
            if img.size[0] <= 512 and img.size[1] <= 512 and img.format == 'JPEG':
                return encode_image_to_base64(image_path)
            else:
                # Resize and convert to JPEG
                img = resize_image(img)
                with BytesIO() as imgio:
                    img.save(imgio, 'JPEG')
                    imgio.seek(0)
                    data = base64.b64encode(imgio.getvalue())
                    return data.decode('utf8')
    except FileNotFoundError as e:
        logging.error("Image file not found: %s - %s", image_path, e)
    except UnidentifiedImageError as e:
        logging.error("Cannot identify image file: %s - %s", image_path, e)
    except Exception as e:
        logging.error("Error processing image for analysis: %s", e)
    return None


###### FILENAME: json_utils.py ######

import os
import json
import logging
from typing import Dict, Any, List

def save_json(file_path: str, data: Dict[str, Any]) -> None:
    try:
        if os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as json_file:
                existing_data = json.load(json_file)
            
            # Update file_info
            existing_data['file_info'] = data['file_info']
            
            # Merge analysis results
            for mode, result in data['analysis'].items():
                if mode not in existing_data['analysis']:
                    existing_data['analysis'][mode] = result
                elif result['model'] != existing_data['analysis'][mode]['model']:
                    existing_data['analysis'][f"{mode}_{result['model']}"] = result
            
            data = existing_data
        
        with open(file_path, 'w', encoding='utf-8') as json_file:
            json.dump(data, json_file, ensure_ascii=False, indent=4)
        logging.info(f"JSON output created/updated: {file_path}")
    except IOError as e:
        logging.error(f"Failed to create or write to file: {e}, Path attempted: {file_path}")

def get_existing_json_files(directory: str) -> List[str]:
    json_files = []
    for root, _, files in os.walk(directory):
        json_files.extend([file for file in files if file.lower().endswith('.json')])
    return json_files

def should_process_file(file_path: str, existing_files: List[str], analyzer_name: str, config) -> bool:
    json_filename = f"{os.path.splitext(os.path.basename(file_path))[0]}_{analyzer_name}.json"
    if json_filename in existing_files:
        with open(os.path.join(config.output_directory, json_filename), 'r') as f:
            existing_data = json.load(f)
        
        # Check if all enabled modes are already processed
        existing_modes = set(existing_data['analysis'].keys())
        required_modes = set(config._get_enabled_modes())
        
        if required_modes.issubset(existing_modes):
            logging.info(f"Skipping {file_path}, all required modes already processed.")
            return False
    return True

def process_existing_json_files(config):
    logging.info("Processing existing JSON files...")
    json_files = get_existing_json_files(config.output_directory)
    
    # Dictionary to store prompts for each mode
    mode_prompts = {mode: [] for mode in config._get_enabled_modes()}
    
    for json_file in json_files:
        file_path = os.path.join(config.output_directory, json_file)
        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            if 'analysis' in data:
                for mode, analysis in data['analysis'].items():
                    if mode in mode_prompts:
                        if 'result' in analysis and isinstance(analysis['result'], str):
                            mode_prompts[mode].append(analysis['result'])
                        elif 'result' in analysis and isinstance(analysis['result'], dict) and 'caption' in analysis['result']:
                            mode_prompts[mode].append(analysis['result']['caption'])
        except Exception as e:
            logging.error(f"Error processing {json_file}: {str(e)}")
    
    # Write prompts to wildcard txt files
    for mode, prompts in mode_prompts.items():
        if prompts:
            wildcard_file = os.path.join(config.output_directory, f"{mode}_wildcards.txt")
            with open(wildcard_file, 'w') as f:
                f.write("\n".join(prompts))
            logging.info(f"Created wildcard file for {mode}: {wildcard_file}")
    
    logging.info("Finished processing existing JSON files")


###### FILENAME: llm_analyzer.py ######

import os
import logging
import requests
from typing import Dict, Any, List
from analyzer import Analyzer
from api_utils import retry_with_backoff, log_api_conversation
from image_utils import encode_image_to_base64

class LLMAnalyzer(Analyzer):
    def __init__(self, config):
        super().__init__(config)
        self.logger = logging.getLogger('LLM_API')

    def _get_enabled_modes(self):
        return self.config.selected_prompts

    @retry_with_backoff(max_retries=3, backoff_factor=2)
    def send_llm_request(self, data: Dict[str, Any]) -> Dict[str, Any]:
        headers = {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {self.config.get_openai_api_key()}"
        }
        
        try:
            response = requests.post(
                self.config.llm_api_base_url,
                headers=headers,
                json=data,
                timeout=self.config.timeout
            )
            response.raise_for_status()
            response_data = response.json()
            
            log_api_conversation(self.logger, {"request": data, "response": response_data})
            
            return response_data
        except requests.RequestException as e:
            self.logger.error(f"Error in LLM API request: {str(e)}")
            self.logger.error(f"Response content: {e.response.text if e.response else 'No response content'}")
            raise

    def analyze_image(self, image_path: str) -> Dict[str, Any]:
        """
        Analyze an image using the LLM API.

        Args:
            image_path (str): Path to the image file.

        Returns:
            Dict[str, Any]: Analysis results for each prompt, or an error dictionary.
        """
        try:
            image_base64 = encode_image_to_base64(image_path)
            results = {}
            for prompt_id in self.config.selected_prompts:
                data = self._prepare_llm_data(image_base64, prompt_id)
                results[prompt_id] = self.send_llm_request(data)
            return results
        except Exception as e:
            self.logger.error(f"Error analyzing image {image_path}: {str(e)}")
            return {'error': str(e)}

    def _prepare_llm_data(self, image_base64: str, prompt_id: str) -> Dict[str, Any]:
        """
        Prepare the data payload for the LLM API request.

        Args:
            image_base64 (str): Base64 encoded image data.
            prompt_id (str): ID of the prompt to use.

        Returns:
            Dict[str, Any]: Prepared data payload for the API request.
        """
        prompt_options = self.config.get_prompt_options(prompt_id)
        return {
            "model": self.config.llm_model,
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {"type": "text", "text": prompt_options['PROMPT_TEXT']},
                        {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{image_base64}"}}
                    ]
                }
            ],
            "temperature": prompt_options['TEMPERATURE'],
            "max_tokens": prompt_options['MAX_TOKENS'],
            "top_p": self.config.top_p,
            "frequency_penalty": self.config.frequency_penalty,
            "presence_penalty": self.config.presence_penalty
        }

    def process_images(self):
        """
        Process all images in the specified directory.
        """
        existing_files = json_utils.get_existing_json_files(self.config.output_directory)
        for image_path in self.get_image_files():
            if json_utils.should_process_file(image_path, existing_files, self.__class__.__name__):
                result = self.analyze_image(image_path)
                self.save_result(image_path, result)




###### FILENAME: logging_setup.py ######

import os
import logging

def setup_logging(config):
    """
    Setup logging configurations based on the configuration values.

    Args:
        config: Configuration object containing logging settings.

    This function sets up file and console logging, as well as specific loggers for API communication, CLIP API, and LLM API.
    """
    logging.getLogger().handlers.clear()

    log_format = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s', datefmt='%d/%m/%y %H:%M')
    console_log_format = logging.Formatter('%(message)s')

    if config.log_to_file:
        log_file_path = os.path.join(config.output_directory, config.log_file)
        os.makedirs(config.output_directory, exist_ok=True)
        file_handler = logging.FileHandler(log_file_path, mode=config.log_mode)
        file_handler.setFormatter(log_format)
        file_handler.setLevel(logging.DEBUG)
        logging.getLogger().addHandler(file_handler)

    if config.log_to_console:
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(console_log_format)
        console_handler.setLevel(logging.INFO)
        console_handler.setStream(open(1, 'w', encoding='utf-8', closefd=False))
        logging.getLogger().addHandler(console_handler)

    def setup_api_logger(name, log_file):
        logger = logging.getLogger(name)
        logger.setLevel(logging.DEBUG)
        handler = logging.FileHandler(os.path.join(config.output_directory, log_file), mode='a', encoding='utf-8')
        handler.setFormatter(log_format)
        logger.addHandler(handler)

    # Set up API logging if enabled
    if config.log_api_communication:
        setup_api_logger('API', 'api_communication.log')

    # Setup CLIP API logger
    setup_api_logger('CLIP_API', 'api_clip.log')

    # Setup LLM API logger
    setup_api_logger('LLM_API', 'api_llm.log')

    logging.getLogger().setLevel(logging.DEBUG)
    logging.getLogger('PIL').setLevel(logging.WARNING)



###### FILENAME: TEST.py ######

import requests

def test_api():
    url = "http://127.0.0.1:7860/sdapi/v1/sd-models"
    try:
        response = requests.get(url, timeout=10)
        print(f"Status Code: {response.status_code}")
        print(f"Response: {response.text[:200]}...")  # Print first 200 characters of response
    except requests.exceptions.RequestException as e:
        print(f"An error occurred: {e}")

if __name__ == "__main__":
    test_api()


###### FILENAME: utils.py ######

import base64
import hashlib
import requests
import os
import logging
from functools import wraps
from PIL import Image
import io
from typing import Optional, Dict, Any, Callable

def safe_api_call(func: Callable) -> Callable:
    """
    Decorator to safely handle API calls and log errors.
    """
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except requests.RequestException as e:
            logging.error(f"API request failed: {str(e)}")
            return {"error": str(e)}
        except Exception as e:
            logging.exception(f"Unexpected error in API call: {str(e)}")
            return {"error": "An unexpected error occurred"}
    return wrapper

def validate_directory(directory: str) -> None:
    """
    Validate if a directory exists and is accessible.
    """
    if not os.path.isdir(directory):
        raise ValueError(f"The specified path is not a valid directory: {directory}")
    if not os.access(directory, os.R_OK):
        raise PermissionError(f"You don't have read permissions for the directory: {directory}")


